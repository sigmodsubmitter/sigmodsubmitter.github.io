<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <!-- <link rel="icon" href="assets/ico/SEAS-favicon.png" type="image/x-icon"> -->
    <!-- <link rel="shortcut icon" href="assets/ico/favicon.png"> -->

    <title>Monkey</title>

    <!-- Bootstrap core CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="assets/css/main.css" rel="stylesheet">
    <!-- Custom styles for this template -->
	<!-- <link rel="stylesheet" href="../assets/css/font-awesome.min.css">
	<link rel="stylesheet" href="../assets/css/font-awesome.css">
 -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!--    <script src="assets/js/jquery.min.js"></script>   -->
<!--	<script src="assets/js/modernizr.custom.js"></script> -->

	<!-- this is not working-->
	<!--
	<script type="text/javascript"> 
		var images = ['header-bg-default.jpg', 'header-bg-snow.jpg', 'header-bg.jpg'];
		$('#headerwrap').css({'background': 'url(assets/img/' + images[Math.floor(Math.random() * images.length)] + ')'});
	</script>
	-->
    <link href='http://fonts.googleapis.com/css?family=Oswald:400,300,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=EB+Garamond' rel='stylesheet' type='text/css'>
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="assets/js/html5shiv.js"></script>
      <script src="assets/js/respond.min.js"></script>
    <![endif]-->
  </head>

  <body data-spy="scroll" data-offset="200" data-target="#navbar-fixed-top">
				
	<!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
		<div class="container">
			<!-- Brand and toggle get grouped for better mobile display -->
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
			        <span class="sr-only">Toggle navigation</span>
			        <span class="icon-bar"></span>
			        <span class="icon-bar"></span>
			        <span class="icon-bar"></span>
				</button>
				<h3><a  href="" class="smoothScroll">&nbsp; </a> &nbsp; <a  href="" class="smoothScroll">&nbsp; </a></h3>
			</div>

			<!-- Collect the nav links, forms, and other content for toggling -->
			<div id="navtext">
				<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
					<ul class="nav navbar-nav navbar-right">
				        <!-- <li class="active"><a href="#home" class="smoothScroll">Home</a></li> -->
				        <!-- <li><a href="#research" class="smoothScroll">Research</a></li> -->
			              <!--
			              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Research<b class="caret"></b></a>
			              <ul class="dropdown-menu">
			                <li><a href="#Guidelines" class="smoothScroll">Solid-State Storage in DBMS</a></li>
			                <li><a href="#Tutorial" class="smoothScroll">Scalable Logging</a></li>
			                <li><a href="#Tutorial" class="smoothScroll">Concurrency in Data Analytics</a></li>
			              </ul>
						-->
 						<li><a href="#bftuning" class="smoothScroll">BF tuning</a></li>
						<li><a href="#holtuning" class="smoothScroll">Holistic Tuning</a></li>
				    </ul>
				</div><!-- end navbar-collapse -->
			</div>
		</div><!-- end container -->
  	</nav>
				


<section id="research">
	<div id="f">
		<div class="container">
			<div class="row">

				<h2 id="bftuning">Tuning LSM Trees</h2>
				<h3> Bloom Filter Tuning </h3>

				<div class="col-lg-4">
					<h4>Dataset and Environment</h4>
					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Index Size (N)</span>
					  <input id="N" type="text" class="form-control" aria-label="Index Size N (elements)" value="1073741824" style="text-align:right"/>
					  <span class="input-group-addon">(elements)</span>
					</div>
					<br>
					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Key-Value pair size (E)</span>
					  <input id="E" type="text" class="form-control" aria-label="Key-Value pair size (bytes)" value="16" style="text-align:right"/>
					  <span class="input-group-addon">(bytes)</span>
					</div>
					<br>
					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Page Size (P)</span>
					  <input id="P" type="text" class="form-control" aria-label="Page Size P (bytes)" value="4096" style="text-align:right"/>
					  <span class="input-group-addon">(bytes)</span>
					</div>

				</div>

				<div class="col-lg-4">
					<h4>Index Tuning</h4>
					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Buffer Size (Mbuffer)</span>
					  <input id="mbuffer" type="text" class="form-control" aria-label="Buffer Size Mbuffer (MB)" value="1" style="text-align:right"/>
					  <span class="input-group-addon">(MB)</span>
					</div>
					<br>
					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Size Ratio (T)</span>
					  <input id="T" type="text" class="form-control" aria-label="Size Ratio T" value="4" style="text-align:right"/>
					  <!-- <span class="input-group-addon">(bytes)</span> -->
					</div>
					<br>
					<div class="input-group input-group-lg">
				      <span class="input-group-addon">Leveling&nbsp;<input id="leveltier" name="ltradio" type="radio" aria-label="level" value="0" checked="true"/></span>
				      <span class="input-group-addon">Tiering&nbsp;<input id="leveltier" name="ltradio" type="radio" aria-label="tier" value="1"/></span>
					</div>

				</div>

				<div class="col-lg-4">
					<h4>Read/Write Costs</h4>
<!-- 				    <div class="input-group input-group-lg">
				      <span class="input-group-addon">0 < R &le; Rmax</span>
				      <input id="RmaxLabel" type="text" class="form-control" placeholder="Rmax = ..." readonly="true" style="text-align:right">
				      <span class="input-group-addon">(#IOs)</span>
				    </div>
 -->	
 					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Bloom filters size</span>
					  <input id="mfilter" type="text" class="form-control" aria-label="Bloom filter size" value="1" style="text-align:right"/>
					  <span class="input-group-addon">(MBs)</span>
					</div>
<!-- 					<div class="input-group input-group-lg">
					  <span class="input-group-addon">Inflicted W</span>
					  <input id="W" type="text" class="form-control" aria-label="Bound for R (#IOs)" style="text-align:right" placeholder="write IOs" readonly="true" />
					  <span class="input-group-addon">(write #IOs)</span>
					</div>
 -->
 				</div>				
			</div>
			<br>
			<div class="row">
				<div class="col-lg-8">
					<h4>LSM Tuning</h4>
					<div class="input-group input-group-lg">
						<textarea id="explanation" rows="12" cols="100" value="" readonly="true">	</textarea>
					</div>
				</div>
				<div class="col-lg-4">
					<h4>Actions</h4>
<!-- 					<div class="input-group input-group-lg">
						<span class="input-group-btn">
							<button class="btn btn-default" type="button" id="RWboundsButton" onclick="clickRWboundsButton()">Get Rmax</button>
						</span>
					</div>
					<br> -->
					<div class="input-group input-group-lg">
						<span class="input-group-btn">
							<button class="btn btn-default" type="button" id="bloomTuningButton" onclick="clickbloomTuningButton()">Get Bloom Filter Tuning</button>
						</span>
					</div>
				</div>
			</div>
			<br>

<!-- In part 1, you input the following parameters:
 num entries in index N
  avg size of entry in bytes E
  size of buffer in bytes, M_buffer
  size ratio T
  tiering vs leveling
  upper bound on read cost
  upper bound on write cost 

The output you get is the false positive rate for each bloom filter, with state-of-the-art and with MonKey. You also get total amount of space needed for the filters with state-of-the-art and MonKey. 


In part 2, you input the following parameters:
  % writes vs reads in workload
  % cost ratio between reads and writes due to hardware 
  number of elements N
  size of each element E
  total main memory in bytes 

  the output you get the optimal holistic tuning: size ratio T, buffer size M_buffer, tiering vs leveling, and M_buffers. You also get read cost, write cost, and expected throughput

Let me know if you have any thoughts. It would be great if you could set up a website with a basic simple interface, and later we can embed the functionality.
 -->


<!-- <table>
<tbody>
	<tr>
		<td><p>Index Size N:</p></td> <td><p><input id="mAge" style="text-align:right" name="age" size="12" type="text"/></p></td>
	</tr>

</tbody>
</table> -->
				


				<h3 id="holtuning"> Holistic Tuning </h3>
				<div class="row">
					<p>Uses the input N, E, P from the top boxes.</p>
					<div class="col-lg-6">
						<div class="input-group input-group-lg">
						  <span class="input-group-addon">Total Memory Size (M)</span>
						  <input id="M" type="text" class="form-control" aria-label="Total Memory Size M (MB)" value="256" style="text-align:right"/>
						  <span class="input-group-addon">(MB)</span>
						</div>
					</div>
					<div class="col-lg-6">
						<div class="input-group input-group-lg">
						<span class="input-group-btn">
							<button class="btn btn-default" type="button" id="holisticTuningButton" onclick="holisticTuning()">Go Tune some LSM!</button>
						</span>
						</div>
					</div>
				</div>

			<div class="row">
				<div class="col-lg-12">
					<h4>Holistic Tuning Details</h4>
					<div class="input-group input-group-lg">
						<textarea id="explanationHolistic" rows="12" cols="120" value="" readonly="true"></textarea>
					</div>
				</div>
			</div>


			</div> <!-- container -->
		</div> <!-- f -->
	</div> <!-- research -->
</section>

<script type="text/javascript">

function Filter() {
	var nokeys;
	var fp;
	var mem;
}

function numberWithCommas(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

function getRadioValueByName(radioName)
{
	var radios = document.getElementsByName(radioName);
	var val;
	for(var i = 0; i < radios.length; i++){
    	if(radios[i].checked){
        	val = radios[i].value;
    	}
	}
    return val;
}

function myLog(x, base)
{
	return Math.log(x) / Math.log(base);
}


function calcBits(filter) {
	var denom=Math.pow(Math.log(2),2);
	return filter.fp == 0 ? 0 : ( - filter.nokeys * Math.log(filter.fp) ) / denom;
}


function calcTotalMemBits(filtersArray) {
	var total = 0;
	for (var i = 0; i < filtersArray.length ; i++) {
		// printf("%d   %d  %f \n", i,  rates[i].size, rates[i].false_positive_rate);
		var val = calcBits(filtersArray[i]);

		total += val;
	}
	return total;
}

function getRmax(lt,N,E,B,T)
{
	var R;
    if (lt==0)
    	R=Math.ceil(myLog(N*E/B,T));
    else if (lt==1)
    	R=(T-1)*Math.ceil(myLog(N*E/B,T));
    return R;
}

function clickRWboundsButton() {

    var N = parseInt(document.getElementById("N").value,10);
    var E = parseInt(document.getElementById("E").value,10);
    var mbuffer = parseFloat(document.getElementById("mbuffer").value)*1048576;
    var T = parseInt(document.getElementById("T").value, 10);
    var leveltier = getRadioValueByName("ltradio");

    console.log(leveltier);
    var Rmax;
    Rmax=getRmax(leveltier,N,E,mbuffer,T);
	document.getElementById('RmaxLabel').value = "Rmax = "+Rmax;


}


function calc_R(f)
{
	var denom = Math.pow(Math.log(2), 2);
	var value = Math.exp(-(f.mem / f.nokeys) * denom);
	return value;
}

function getBaselineFPassigment(N,E,mbuffer,T,mfilter,P,leveltier)
{
	var filter_array = [];
	var remainingKeys=N;
	var level=0;
	//Calculate the number of keys per level in a almost-full in each level LSM tree
	while (remainingKeys>0)
	{
		level++;
		var levelKeys=Math.ceil(Math.min(Math.pow(T,level)*mbuffer/E,N));
		var newFilter = new Filter();
		newFilter.nokeys=levelKeys;
		newFilter.fp=0.0;
		// console.log("New remaining keys: "+(remainingKeys-levelKeys))
		if (remainingKeys-levelKeys<0)
			newFilter.nokeys=remainingKeys;
		console.log(newFilter.nokeys)
		filter_array.push(newFilter);
		remainingKeys=remainingKeys-levelKeys;
		// console.log(levelKeys)
	}

	var maxNumRuns;
	if (leveltier==0)
		maxNumRuns=filter_array.length;
	else if (leveltier==1)
		maxNumRuns=filter_array.length*(T-1);

	//Initialize the memory per level to be equal
	for (var i=0;i<filter_array.length;i++)
	{
		filter_array[i].mem=mfilter/filter_array.length;
	}

	// console.log(filter_array);
	
	var limit_on_M=mbuffer*8; //amount of memory for filters in bits
	var diff = limit_on_M;
    var change = true;
    var iteration = 0;

    while (diff > 1) {
        change = false;
        for (var i = 0; i < filter_array.length - 1; i++) {
            for (var j = i + 1; j < filter_array.length ; j++) {

                var f1_orig = calc_R(filter_array[i]);
                var f2_orig = calc_R(filter_array[j]);
                // console.log(f1_orig+', '+f2_orig)
                var diff_orig = Math.abs(f1_orig - f2_orig);

                filter_array[i].mem += diff;
                filter_array[j].mem -= diff;

                var f1_new = calc_R(filter_array[i]);
                var f2_new = calc_R(filter_array[j]);
                var diff_new = Math.abs(f1_new - f2_new);
                // console.log(f1_new+', '+f2_new)


                if (diff_new < diff_orig && filter_array[j].mem > 0 && filter_array[i].mem > 0) {
                    change = true;
                    continue;
                }
                filter_array[i].mem -= diff * 2;
                filter_array[j].mem += diff * 2;

                f1_new = calc_R(filter_array[i]);
                f2_new = calc_R(filter_array[j]);
                diff_new = Math.abs(f1_new - f2_new);

                if (diff_new < diff_orig && filter_array[j].mem > 0 && filter_array[i].mem > 0) {
                    change = true;
                    continue;
                }
                filter_array[i].mem += diff;
                filter_array[j].mem -= diff;
            }
        }
        if (!change) {
            diff /= 2;
        }
        iteration++;
    }

  	for (var i = 0; i < filter_array.length; i++) {
        filter_array[i].fp = calc_R(filter_array[i]);
        // console.log(filter_array[i].mem+', '+filter_array[i].fp)
    }
    return filter_array;	
}


function clickbloomTuningButton() {
    var N = parseInt(document.getElementById("N").value,10);
    var E = parseInt(document.getElementById("E").value,10);
    var mbuffer = parseFloat(document.getElementById("mbuffer").value)*1048576;
    var T = parseInt(document.getElementById("T").value, 10);
	var mfilter = parseFloat(document.getElementById("mfilter").value)*1048576;
    var P = parseInt(document.getElementById("P").value, 10);
    //var W = parseFloat(document.getElementById("W").value);
    var leveltier = getRadioValueByName("ltradio");
    


	var filters_baseline=getBaselineFPassigment(N,E,mbuffer,T,mfilter,P,leveltier);
	console.log(filters_baseline);
    // here we have the baseline lsm tuning for FP
    // NORMALLY WE GENERATE SOME OUTPUT HERE

	return;
	
	//Initialize the false positive so that they are all equal
	for (var i=0;i<filter_array.length;i++)
	{
		filter_array[i].fp=R/maxNumRuns;
	}
	var regularFP=R/maxNumRuns;
	var regularBFsizeMB=calcTotalMemBits(filter_array)/8/1024/1024;
	console.log("The size of the default LSM tree in MB: "+(calcTotalMemBits(filter_array)/8/1024/1024))


	return;

	var diff = 0.001;
	var current_num_bits = calcTotalMemBits(filter_array);
	var original = current_num_bits;
	//console.log("start val:  %f\n", current);

	console.log("uniform strategy:  "+ current_num_bits / (8 * 1024) );

	//prvar(filter_array, current, 0);

	var change = true;
	var iteration = 0;
	while (true) {
		change = false;

		for (var i = 0; i < filter_array.length - 1; i++) {
			for (var j = i + 1; j < filter_array.length ; j++) {

				filter_array[i].fp += diff;
				filter_array[j].fp -= diff;
				var value = calcTotalMemBits(filter_array);
				if (value < current_num_bits && value > 0 && filter_array[j].fp > 0 && filter_array[i].fp < 1) {
					current_num_bits = value;
					change = true;
					continue;
				}
				filter_array[i].fp -= diff * 2;
				filter_array[j].fp += diff * 2;

				value = calcTotalMemBits(filter_array);

				if (value < current_num_bits && value > 0 && filter_array[i].fp > 0 && filter_array[j].fp < 1) {
					current_num_bits = value;
					change = true;
					continue;
				}

				filter_array[i].fp += diff;
				filter_array[j].fp -= diff;
			}
		}
		if (!change) {
			diff /= 2;
			if (diff < 0.0000001) {
				break;
			}
		}
		//prvar(filter_array, current, iteration);
		iteration++;
		//prvar_detail(filter_array, current);
	}
	// prvar_detail(filter_array, current_num_bits);
	console.log("ratio saving  "+ current_num_bits / original );
	console.log("original "+ original / (8 * 1024)+"KB");
	//total_uniform_RAM3(limit_on_reads, size_ratio, filter_array.back().size, page_size);
	console.log("current "+ current_num_bits / (8 * 1024)+"KB");
	//console.log("size:  %ld\n", filter_array.back().size);


	for (var i=0;i<filter_array.length;i++)
	{
		if (Math.abs(filter_array[i].fp-1)<0.0000001)
			filter_array[i].fp=1.0;
	}


	console.log(filter_array.length);
	console.log(filter_array);

	document.getElementById("explanation").value ="";
	document.getElementById("explanation").value = "The LSM tree holds "+(N*E/1024/1024).toFixed(1)+" MB of Key-Value pairs.\n";
	document.getElementById("explanation").value += "Level 0 buffer size is "+(mbuffer/1024/1024).toFixed(1)+" MB.\n";
	var bf_total_size=calcTotalMemBits(filter_array);
	document.getElementById("explanation").value += "Bloom filter memory consumtion for state-of-the-art is "+(regularBFsizeMB).toFixed(1)+" MB.\n";
	document.getElementById("explanation").value += "Bloom filter memory consumtion for MonKey is "+(bf_total_size/8/1024/1024).toFixed(1)+" MB, i.e., "+(regularBFsizeMB/(bf_total_size/8/1024/1024)).toFixed(2)+ "x smaller.\n";
	

	document.getElementById("explanation").value += ("Level\t\t#Keys\t\tfp (%)\t\tfp state-of-art\n");
	var total_keys=0;
	for (var i=0;i<filter_array.length;i++)
	{
		console.log(filter_array[i].nokeys+", "+filter_array[i].fp);
		total_keys+=filter_array[i].nokeys;
		document.getElementById("explanation").value += ("  "+(i+1)+"  \t\t"+pad(numberWithCommas(filter_array[i].nokeys),12," ")+"\t\t"+(100*filter_array[i].fp).toFixed(2)+"%\t\t"+(100*regularFP).toFixed(2)+"%\n");

	}
	console.log("Total indexed keys: "+total_keys);


    var W;
    var entries_per_page=Math.floor(P/E);
    if (leveltier==0)
    	W=(filter_array.length/entries_per_page)*(T-1)/2;
    else if (leveltier==1)
    	W=(filter_array.length/entries_per_page)*(T-1)/T;

	document.getElementById("W").value = W.toFixed(4);

}


function clickbloomTuningButton_OLD() {

// document.getElementById("mEV").value=document.getElementById("mEV").value.replace(/\./g,"");
// document.getElementById("mPWage").value=document.getElementById("mPWage").value.replace(/\./g,"");

    var N = parseInt(document.getElementById("N").value,10);
    var E = parseInt(document.getElementById("E").value,10);
    var mbuffer = parseFloat(document.getElementById("mbuffer").value)*1048576;
    var T = parseInt(document.getElementById("T").value, 10);
    var R = parseFloat(document.getElementById("R").value);
    var P = parseInt(document.getElementById("P").value, 10);
    var W = parseFloat(document.getElementById("W").value);
    var leveltier = getRadioValueByName("ltradio");
    
    Rmax=getRmax(leveltier,N,E,mbuffer,T);
	document.getElementById('RmaxLabel').value = "Rmax = "+Rmax;

	if (R>Rmax)
	{
			document.getElementById("explanation").value = ("Rmax = "+Rmax+", and you selected R = "+R+". Please select an R < Rmax.");
			return;
	}		

	var filter_array = [];
	var remainingKeys=N;
	var level=0;
	//Calculate the number of keys per level in a almost-full in each level LSM tree
	while (remainingKeys>0)
	{
		level++;
		var levelKeys=Math.ceil(Math.min(Math.pow(T,level)*mbuffer/E,N));
		var newFilter = new Filter();
		newFilter.nokeys=levelKeys;
		newFilter.fp=1.0;
		console.log("New remaining keys: "+(remainingKeys-levelKeys))
		if (remainingKeys-levelKeys<0)
			newFilter.nokeys=remainingKeys;
		filter_array.push(newFilter);
		remainingKeys=remainingKeys-levelKeys;
		console.log(levelKeys)
	}

	var maxNumRuns;
	if (leveltier==0)
		maxNumRuns=filter_array.length;
	else if (leveltier==1)
		maxNumRuns=filter_array.length*(T-1);
	
	//Initialize the false positive so that they are all equal
	for (var i=0;i<filter_array.length;i++)
	{
		filter_array[i].fp=R/maxNumRuns;
	}
	var regularFP=R/maxNumRuns;
	var regularBFsizeMB=calcTotalMemBits(filter_array)/8/1024/1024;
	console.log("The size of the default LSM tree in MB: "+(calcTotalMemBits(filter_array)/8/1024/1024))




	var diff = 0.001;
	var current_num_bits = calcTotalMemBits(filter_array);
	var original = current_num_bits;
	//console.log("start val:  %f\n", current);

	console.log("uniform strategy:  "+ current_num_bits / (8 * 1024) );

	//prvar(filter_array, current, 0);

	var change = true;
	var iteration = 0;
	while (true) {
		change = false;

		for (var i = 0; i < filter_array.length - 1; i++) {
			for (var j = i + 1; j < filter_array.length ; j++) {

				filter_array[i].fp += diff;
				filter_array[j].fp -= diff;
				var value = calcTotalMemBits(filter_array);
				if (value < current_num_bits && value > 0 && filter_array[j].fp > 0 && filter_array[i].fp < 1) {
					current_num_bits = value;
					change = true;
					continue;
				}
				filter_array[i].fp -= diff * 2;
				filter_array[j].fp += diff * 2;

				value = calcTotalMemBits(filter_array);

				if (value < current_num_bits && value > 0 && filter_array[i].fp > 0 && filter_array[j].fp < 1) {
					current_num_bits = value;
					change = true;
					continue;
				}

				filter_array[i].fp += diff;
				filter_array[j].fp -= diff;
			}
		}
		if (!change) {
			diff /= 2;
			if (diff < 0.0000001) {
				break;
			}
		}
		//prvar(filter_array, current, iteration);
		iteration++;
		//prvar_detail(filter_array, current);
	}
	// prvar_detail(filter_array, current_num_bits);
	console.log("ratio saving  "+ current_num_bits / original );
	console.log("original "+ original / (8 * 1024)+"KB");
	//total_uniform_RAM3(limit_on_reads, size_ratio, filter_array.back().size, page_size);
	console.log("current "+ current_num_bits / (8 * 1024)+"KB");
	//console.log("size:  %ld\n", filter_array.back().size);


	for (var i=0;i<filter_array.length;i++)
	{
		if (Math.abs(filter_array[i].fp-1)<0.0000001)
			filter_array[i].fp=1.0;
	}


	console.log(filter_array.length);
	console.log(filter_array);

	document.getElementById("explanation").value ="";
	document.getElementById("explanation").value = "The LSM tree holds "+(N*E/1024/1024).toFixed(1)+" MB of Key-Value pairs.\n";
	document.getElementById("explanation").value += "Level 0 buffer size is "+(mbuffer/1024/1024).toFixed(1)+" MB.\n";
	var bf_total_size=calcTotalMemBits(filter_array);
	document.getElementById("explanation").value += "Bloom filter memory consumtion for state-of-the-art is "+(regularBFsizeMB).toFixed(1)+" MB.\n";
	document.getElementById("explanation").value += "Bloom filter memory consumtion for MonKey is "+(bf_total_size/8/1024/1024).toFixed(1)+" MB, i.e., "+(regularBFsizeMB/(bf_total_size/8/1024/1024)).toFixed(2)+ "x smaller.\n";
	

	document.getElementById("explanation").value += ("Level\t\t#Keys\t\tfp (%)\t\tfp state-of-art\n");
	var total_keys=0;
	for (var i=0;i<filter_array.length;i++)
	{
		console.log(filter_array[i].nokeys+", "+filter_array[i].fp);
		total_keys+=filter_array[i].nokeys;
		document.getElementById("explanation").value += ("  "+(i+1)+"  \t\t"+pad(numberWithCommas(filter_array[i].nokeys),12," ")+"\t\t"+(100*filter_array[i].fp).toFixed(2)+"%\t\t"+(100*regularFP).toFixed(2)+"%\n");

	}
	console.log("Total indexed keys: "+total_keys);


    var W;
    var entries_per_page=Math.floor(P/E);
    if (leveltier==0)
    	W=(filter_array.length/entries_per_page)*(T-1)/2;
    else if (leveltier==1)
    	W=(filter_array.length/entries_per_page)*(T-1)/T;

	document.getElementById("W").value = W.toFixed(4);

}

//////////////////////////////////////
//AUX HOLISTIC TUNING FUNCTIONS

function LSM_config() {
	var P;
	var T;
	var L;
	var N;
	var R;
	var W;
	var M;
	var B;
	var E;
	var valid;
	var throughput;
	var num_levels;
}

// returns write cost 
function get_W(N, T, B, P, leveled) {
	if (P * B >= N) {
		return 0;
	}

	var loga = Math.ceil(Math.log(N / (B * P)) / Math.log(T));
	var denom = leveled ? 2.0 : T;
	var all =  ((T - 1.0) / denom);
	all = loga * all ;
	all = all + 1;
	all = all / B;
	return all;
}

// read cost under state-of-the-art approach
function get_R_uniform_strategy(M, T, N, B, P, leveled) {
	M = M * (8 * 1024);
	
	if (P * B >= N) {
		return 0;
	}

	if (M <= 0) {
		var c = Math.log(N / (B * P));
		var  b = c / Math.log(T);
		var  a = 1.0 + Math.ceil( b );
		a *= leveled ? 1 : (T - 1);
		return a;
	}

	//double L = !leveled ? floor(1 +  log(N/(B * P)) / log(T)) : ceil(1 +  log(N/(B * P)) / log(T));
	//double L = !leveled ? floor(1 +  log(N/(B * P)) / log(T)) : ceil(1 +  log(N/(B * P)) / log(T));
	var L = Math.ceil(1 +  Math.log(N/ (B * P)) / Math.log(T));
	if (!leveled) {
		//L--;
	}
	var T_part = (T - 1) / (T * ( 1 - Math.pow(T, -L) ));

	var exponent = (M / N) * Math.log(2) * Math.log(2) * T_part;

	var EULER = 2.71828182845904523536;
	var bottom = Math.pow(EULER, exponent);
	var R = L / bottom;
	if (!leveled) {
		R *= T - 1;
	}
	return R;
}


// read cost under MonKey
function get_accurate_R(M, T, N, B, P, leveled) {

	if (P * B >= N) {
		return 0;
	}

	if (M <= 0) {
		var c = Math.log(N / (B * P));
		var b = c / Math.log(T);
		var a = 1.0 + Math.ceil( b );
		a *= leveled ? 1 : (T - 1);
		return a;
	}



	var F = N / Math.pow(Math.log(2), 2);
	F *= T / Math.pow((T - 1), 2);
	F *= Math.log(T);
	F /= 8 * 1024;

	var j = Math.max(Math.ceil(Math.log(F / M) / Math.log(T)), 0.0);
	var L = Math.ceil(1 + Math.log(N / (B * P)) / Math.log(T)) - j;
	//printf("%f\n", L);
	//double L = !leveled ? floor(1 +  log(N/(B * P)) / log(T)) : ceil(1 +  log(N/(B * P)) / log(T));

	N /= Math.pow(T, j);

	var Y = 1 - L / Math.pow(T, L);
	Y += (1 - Math.pow(1/T, L - 1.0)) / (T - 1.0);
	Y = Math.pow(T, Y);

	var S = leveled ? (T - 1) : 1.0;
	var X = Math.pow(T, L) * (S / (Math.pow(T, L) - 1));;
	X = Math.pow(X, 1 - Math.pow(1/T, L));

	var E = ((M * 8 * 1024) / N) * ((T - 1) / T) * Math.pow(Math.log(2), 2);

	var EULER = 2.71828182845904523536;
	E = Math.pow(EULER, E);

	var product = Y / (X * E);

	var raised = Math.pow(product, Math.pow(T, L) / (Math.pow(T, L) - 1));

	return raised + j * (leveled ? 1 : T - 1.0);
}

//////////////////////////////////////

function holisticTuning()
{
    var N = parseInt(document.getElementById("N").value,10);
    var E = parseInt(document.getElementById("E").value,10);
    var M = parseInt(document.getElementById("M").value, 10)*1048576;
    var page_size = parseInt(document.getElementById("P").value, 10);
    document.getElementById("explanationHolistic").value="";

    var conf = new LSM_config();
    conf.N=N;
    conf.E=E;
    conf.B=page_size/E;
    conf.M=M;

	conf.P=0;
	conf.T=0;
	conf.L=0;
	conf.R=0;
	conf.W=0;
	conf.valid=false;
	conf.throughput=0;
	conf.num_levels=0;
	console.log("start")
    print_csv_experiment(conf,0,true,-1,true,true,true);

// function print_csv_experiment(conf, num_commas, print_details, fix_buffer_size = -1, use_new_strategy = true, smoothing = false, differentiate_tiered_leveled = true) {

}


function smooth(to_print) {
	var num_elimintated = 0;
	for (var i = 2; i < to_print.length; i++) {
		var c1 = to_print[i-2];
		var c2 = to_print[i-1];
		var c3 = to_print[i];
		var rise1 = c2.R - c1.R;
		var run1 = c2.W - c1.W;
		var gradient1 = Math.abs(rise1 / run1);

		var rise2 = c3.R - c1.R;
		var run2 = c3.W - c1.W;
		var gradient2 = Math.abs(rise2 / run2);

		if (gradient1 < gradient2) {
			// to_print.erase(to_print.begin() + i - 1);
			to_print.splice(i - 1,1);
			num_elimintated++;
		}
	}
	return num_elimintated;
}

function print_csv_line(c, num_commas, print_details, differentiate_tiered_leveled) {
	// printf("%.7f, ", c.W);
	var message="";
	message+=((c.W).toFixed(4));

	message+=(", ");



	// if (c.L == 1 && differentiate_tiered_leveled) {
	// 	// printf(", ");
	// 	message+=(", ");
	// }

	// for (var j = 0; j < num_commas; j++) {
	// 	// printf(", ");
	// 	message+=(", ");
	// 	if (differentiate_tiered_leveled) {
	// 		message+=(", ");
	// 		// printf(", ");
	// 	}
	// }

	// printf("%.4f", c.R);
	message+=" ";
	message+=(  pad((c.R).toFixed(4),7," ")  );

	if (print_details) {
		// printf(",\t%g,\t%g,\t%g,\t%g", c.T, c.P, c.L, c.num_levels);
		var TL=((c.L==0)?"tier":"level");
		var memory_for_level_0=(c.P*c.B*c.E);
		var memory_for_BF=c.M-memory_for_level_0;
		var level_0_size_MB=memory_for_level_0/1024/1024;
		var BF_size_MB=memory_for_BF/1024/1024;
		message+=(",\t"+pad(c.T,4," ")+",\t"+pad(level_0_size_MB.toFixed(2),7," ")+",\t"+pad(TL,5," ")+",\t"+c.num_levels+",\t\t"+(BF_size_MB).toFixed(2));
	}
	console.log(message);
	document.getElementById("explanationHolistic").value+=(message+"\n");
	// printf("\n");
}




// Iterate through leveling/tiering, size ratio T, and buffer size P to find optimal parameters
function find_optimal_R(input_conf, constant_buffer_size = -1, use_new_bloom_tuning = true) {
	
	var conf = new LSM_config();
	conf.P=input_conf.P;
	conf.T=input_conf.T;
	conf.L=input_conf.L;
	conf.N=input_conf.N;
	conf.R=input_conf.R;
	conf.W=input_conf.W;
	conf.M=input_conf.M;
	conf.B=input_conf.B;
	conf.E=input_conf.E;
	conf.valid=input_conf.valid;
	conf.throughput=input_conf.throughput;
	conf.num_levels=input_conf.num_levels;

	var N = conf.N;
	var B = conf.B;
	var E = conf.E;
	var M = conf.M;
	var W = conf.W;
	conf.valid = false;

	var max_elements_in_buffer = N;

	var starting_buffer_size = 1;
	if (constant_buffer_size > -1) {
		starting_buffer_size = constant_buffer_size / (E * B);
		max_elements_in_buffer = starting_buffer_size * B;
	}

	var min_W = 1;
	var min_R = (1 + Math.log(N) / Math.log(2)) * B, best_T = 2, best_P = 1;
	var is_leveled = 1;
	for (var T = 2; T < B; T++) {
		for (var P = starting_buffer_size;  P * B <= max_elements_in_buffer; P *= T) {
			for (var L = 0; L <= 1; L++) {

				var leveled = L;
				var num_levels = 1 + Math.ceil(Math.log(N / (B * P)) / Math.log(T));
				var real_P = Math.ceil(N / (B * Math.pow(T, num_levels - 1)));

				if (T > N / (B * real_P)) {
					continue;
				}

				var mem_for_bloom = M - real_P * B * E;

				var current_R = use_new_bloom_tuning ? get_accurate_R(mem_for_bloom / 1024, T, N, B, real_P, leveled) :
						get_R_uniform_strategy(mem_for_bloom / 1024, T, N, B, real_P, leveled);

				var current_W = get_W(N, T, B, P, leveled);
				if (mem_for_bloom >= 0 && current_R < min_R && current_W < W) {
					min_R = current_R;
					best_T = T;
					best_P = real_P;
					min_W = current_W;
					is_leveled = leveled;
					conf.W = current_W;
					conf.valid = true;
					conf.num_levels = Math.ceil(1 +  Math.log(N/(B * P)) / Math.log(T));
					if (use_new_bloom_tuning == false) {
						//printf("  --->   ");
						//printf("   %f  %f   %f  %f  %f\n", mem_for_bloom / 1024, T, P, current_R, current_W);
						//get_R_uniform_strategy(mem_for_bloom / 1024, T, N, B, P, !is_leveled);
					}
				}
			}
		}
	}
	//printf("optimal T:  %f \n", best_T);
	//printf("optimal P:  %f \n", best_P);
	//printf("Leveled:  %s \n", is_leveled ? "true" : "false");
	conf.T = best_T;
	conf.P = best_P;
	conf.L = is_leveled;
	conf.R = min_R;
	return conf;
}






// Find the corresponding optimal read cost for different upper bounds on write cost
function print_csv_experiment(input_conf, num_commas, print_details, fix_buffer_size = -1, use_new_strategy = true, smoothing = false, differentiate_tiered_leveled = true) {
	
	var conf = new LSM_config();
	conf.P=input_conf.P;
	conf.T=input_conf.T;
	conf.L=input_conf.L;
	conf.N=input_conf.N;
	conf.R=input_conf.R;
	conf.W=input_conf.W;
	conf.M=input_conf.M;
	conf.B=input_conf.B;
	conf.E=input_conf.E;
	conf.valid=input_conf.valid;
	conf.throughput=input_conf.throughput;
	conf.num_levels=input_conf.num_levels;

	var prev_W = -1;
	var prev_L = 0;

	var array_to_print = new Array();

	//print_write_optimized_extreme(conf, use_new_strategy);

	var last_c = LSM_config();
	for (var W = 0.001; W <= 0.09; W += 0.001) {
		conf.W = W;

		var c = find_optimal_R(conf, fix_buffer_size, use_new_strategy);
		// print_csv_line(c,num_commas,print_details,differentiate_tiered_leveled);

		if ((prev_W == c.W && prev_L == c.L) || !c.valid) {
			continue;
		}
		prev_W = c.W;
		prev_L = c.L;

		if (c.L == 1 && last_c.L == 0 && last_c.T == 2 && differentiate_tiered_leveled) {
			last_c.L = 1;
			array_to_print.push(last_c);
			//print_csv_line(last_c, num_commas, print_details);
		}

		array_to_print.push(c);
		//print_csv_line(c, num_commas, print_details);

		last_c = c;
	}

	var num_eliminated = 1;
	while (smoothing && num_eliminated > 0) {
		num_eliminated = smooth(array_to_print);
		//printf("%d   \n", num_eliminated);
	}

	console.log("printing "+array_to_print.length+" rows")
	
	document.getElementById("explanationHolistic").value+=("Printing the "+array_to_print.length+ " configurations on the performance skyline.\n");
	document.getElementById("explanationHolistic").value+=("write,\tread,\tT,\tL0 (MB),  merge,  levels,\tBF (MB)\n");

	for (var i = 0; i < array_to_print.length; i++) {
		print_csv_line(array_to_print[i], num_commas, print_details, differentiate_tiered_leveled);
	}

	// printf("\n");
}


</script>



<!-- 	  <div id="preload">
  		 	<img alt="Background" height="1" src="../assets/img/header_bg.jpg" width="1"/>
  		</div>
 -->

      <footer>

        <div class="row">
          <div class="col-lg-12">
              <p class="text-center">
              <br>&copy; 2016 Sigmod Submitter </p>
              <br/>
              <br/>
              <br/>
            </div>
          </div>



      </footer>
	

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	<!-- <script src="assets/js/classie.js"></script> -->
    <script src="assets/js/bootstrap.min.js"></script>
    <script src="assets/js/smoothscroll.js"></script>
	<script src="assets/js/main.js"></script>

	<script type="text/javascript">
	
	 // Changing navbar
  function updateNavbar() {
  	var inverse = true;
	// Disable changing navbar on mobile device
	if( $( window ).width() < 500){
		inverse = true;
	} else {
		if (false)
		{
			var scroll_start = 0;
			var startchange = $('header .intro-lead-in');
			var offset = startchange.offset();
			scroll_start = $(this).scrollTop();
			if(scroll_start > (offset.top - 50)) {
				inverse = true;
			}
		}
	}
	  
	if(inverse) {
		$('.navbar').addClass('navbar-inverse').removeClass('navbar-clear');
    } else {
		$('.navbar').removeClass('navbar-inverse').addClass('navbar-clear');
    }
  }
  
  // Registere events and initialize navbar
  $(document).scroll(updateNavbar);
  $(window).resize(updateNavbar);
  updateNavbar();

  // Highlight the top nav as scrolling occurs
  $('body').scrollspy({target: '.navbar-fixed-top'});
  //$('body').scrollspy({target: '.navbar-fixed-top'; offset: offsetHeight;});

  // Close the Responsive Menu on Menu Item Click
  $('.navbar-collapse ul li a').click(function() {
    $('.navbar-toggle:visible').click();
	});
	
	$('a[href*=#]').on('click', function(event){     
    event.preventDefault();
    var pos = 0;
    if(this.hash){
    	pos = $(this.hash).offset().top;
    }
    	$('html,body').animate({scrollTop:pos}, 600);
});

    </script>
	

	
</body>
</html>

